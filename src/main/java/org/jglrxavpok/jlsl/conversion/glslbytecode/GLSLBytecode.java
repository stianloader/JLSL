package org.jglrxavpok.jlsl.conversion.glslbytecode;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jglrxavpok.jlsl.conversion.IndentedStringWriter;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * The GLSL Bytecode specification.
 * GLSL Bytecode is a format used to store a GLSL program in a binary format.
 * It is used as an intermediate format between any other language and the GLSL language.
 * <br>
 * The format is a tree based format, where each node may have other nodes.
 */
public class GLSLBytecode {

    ///////////
    // Nodes //
    ///////////

    public interface Node {
        void generateSource(@NotNull IndentedStringWriter writer);

        default @NotNull String generateSource(@NotNull String indent) {
            IndentedStringWriter writer = new IndentedStringWriter(indent);
            generateSource(writer);
            return writer.toString();
        }
    }

    /**
     * The root node of the GLSL Bytecode tree.
     */
    public record Root(int version, @NotNull List<? extends @NotNull TopLevelNode> nodes) implements Node {

        public Root(int version, @NotNull TopLevelNode... nodes) {
            this(version, List.of(nodes));
        }

        public Root(int version, @NotNull Collection<? extends TopLevelNode>... nodeCollections) {
            this(version, Stream.of(nodeCollections).flatMap(Collection::stream).toList());
        }

        @Override
        public void generateSource(@NotNull IndentedStringWriter writer) {
            writer.write("#version " + version + " core\n");
            writer.write("// Generated by JLSL\n");
            writer.write("\n");
            for (TopLevelNode node : nodes) {
                node.generateSource(writer);
            }
        }
    }

    /**
     * A top-level field.
     * e.g.
     * <pre>
     *     uniform float u_time;
     *     uniform vec3 u_cameraPos;
     *     uniform vec3 u_cameraDir;
     * </pre>
     */
    public record Field(@Nullable Field.Type fieldType, @NotNull String name,
                        @NotNull GLSLBytecode.Type valueType) implements TopLevelNode {

        /**
         * The type of the field.
         */
        public enum Type implements Node {
            UNIFORM("uniform"),
            IN("in"),
            OUT("out");

            private final String display;

            Type(String display) {
                this.display = display;
            }

            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                writer.write(this.display);
            }
        }

        @Override
        public void generateSource(@NotNull IndentedStringWriter writer) {
            if (fieldType != null) {
                fieldType.generateSource(writer);
                writer.write(" ");
            }
            valueType.generateSource(writer);
            writer.write(" ");
            writer.write(name);
            writer.write(";\n");
        }
    }

    /**
     * A GLSL method.
     * e.g.
     * <pre>
     *     void main() {
     *         if (1 == 1) {
     *             int a = 1;
     *         }
     *     }
     * </pre>
     * @param returnType the return type of the method
     * @param name the callingfield of the method
     * @param parameters the parameters of the method
     * @param body the body of the method
     */
    public record Method(@NotNull Type returnType, @NotNull String name, @NotNull List<@NotNull Parameter> parameters,
                         @NotNull Body body) implements TopLevelNode {

        /**
         * A method parameter.
         * e.g.
         * <pre>
         *     float someFloat
         *     vec3 aVector
         *     vec3[] aVectorArray
         * </pre>
         */
        public record Parameter(@NotNull String name, @NotNull Type type) implements Node {
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                type.generateSource(writer);
                writer.write(" ");
                writer.write(name);
            }
        }

        @Override
        public void generateSource(@NotNull IndentedStringWriter writer) {
            // Return + callingfield
            returnType.generateSource(writer);
            writer.write(" ");
            writer.write(name);
            writer.write("(");

            // Parameters
            for (int i = 0; i < parameters.size(); i++) {
                if (i > 0) {
                    writer.write(", ");
                }
                parameters.get(i).generateSource(writer);
            }
            writer.write(") {");
            writer.indent();
            writer.newLine();
            body.generateSource(writer);
            writer.unindent();
            writer.write("}");
            writer.newLine();
        }
    }

    /**
     * A body of code.
     * e.g. the body of a method, the body of an if statement, and the body of a for loop.
     */
    public record Body(@NotNull List<@NotNull Statement> statements) implements Node {
        public Body(@NotNull Statement... statements) {
            this(List.of(statements));
        }

        @Override
        public void generateSource(@NotNull IndentedStringWriter writer) {
            for (Statement statement : statements) {
                statement.generateSource(writer);
            }
        }
    }

    /**
     * A statement.
     * <br>
     * Statements are the lines of code found within a body.
     */
    public interface Statement extends Node {

        interface Condition extends Statement {
            record EqualTo(@NotNull Value left, @NotNull Value right) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    left.generateSource(writer);
                    writer.write(" == ");
                    right.generateSource(writer);
                }
            }

            record Not(@NotNull Condition condition) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    writer.write("!(");
                    condition.generateSource(writer);
                    writer.write(")");
                }
            }

            record NotEqualTo(@NotNull Value left, @NotNull Value right) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    left.generateSource(writer);
                    writer.write(" != ");
                    right.generateSource(writer);
                }
            }

            record And(@NotNull Condition left, @NotNull Condition right) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    left.generateSource(writer);
                    writer.write(" && ");
                    right.generateSource(writer);
                }
            }

            record Or(@NotNull Condition left, @NotNull Condition right) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    writer.write("(");
                    left.generateSource(writer);
                    writer.write(" || ");
                    right.generateSource(writer);
                    writer.write(")");
                }
            }

            record GreaterThan(@NotNull Value leftValue, @NotNull Value rightValue) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    leftValue.generateSource(writer);
                    writer.write(" > ");
                    rightValue.generateSource(writer);
                }
            }

            record GreaterThanOrEqualTo(@NotNull Value leftValue, @NotNull Value rightValue) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    leftValue.generateSource(writer);
                    writer.write(" >= ");
                    rightValue.generateSource(writer);
                }
            }

            record LessThan(@NotNull Value leftValue, @NotNull Value rightValue) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    leftValue.generateSource(writer);
                    writer.write(" < ");
                    rightValue.generateSource(writer);
                }
            }

            record LessThanOrEqualTo(@NotNull Value leftValue, @NotNull Value rightValue) implements Condition {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    leftValue.generateSource(writer);
                    writer.write(" <= ");
                    rightValue.generateSource(writer);
                }
            }
        }

        /**
         * An if statement.
         * e.g.
         * <pre>
         *     int a = 1;
         *     int b = 2;
         *     int c = a + b;
         *     if (c == 3) {
         *         // The world is all in order
         *     } else {
         *         // You have broken the cosmos beyond repair
         *     }
         * </pre>
         */
        record If(@NotNull Condition condition, @NotNull Body body, @Nullable Body elseBody) implements Statement {
            public If(@NotNull Condition condition, @NotNull Body body) {
                this(condition, body, null);
            }
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                // If statement + condition
                writer.write("if (");
                condition.generateSource(writer);
                writer.write(") {");
                writer.indent();
                writer.newLine();

                // First body
                body.generateSource(writer);

                // Else body if any
                writer.unindent();
                if (elseBody == null) {
                    writer.write("}");
                } else {
                    writer.write("} else {");
                    writer.indent();
                    writer.newLine();
                    elseBody.generateSource(writer);
                    writer.unindent();
                    writer.write("}");
                }
                writer.newLine();
            }
        }

        record DeclareVariable(@NotNull Type type, @NotNull String name, @Nullable Value value) implements Statement {
            public DeclareVariable(@NotNull Type type, @NotNull String name) {
                this(type, name, null);
            }
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                type.generateSource(writer);
                writer.write(" ");
                writer.write(name);
                if (value != null) {
                    writer.write(" = ");
                    value.generateSource(writer);
                }
                writer.write(";");
                writer.newLine();
            }
        }

        record UpdateVariable(@NotNull Value.Reference reference, @NotNull Value value) implements Statement {
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                reference.generateSource(writer);
                writer.write(" = ");
                value.generateSource(writer);
                writer.write(";");
                writer.newLine();
            }
        }

        record Return(@Nullable Value value) implements Statement {
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                writer.write("return");
                if (value != null) {
                    writer.write(" ");
                    value.generateSource(writer);
                }
                writer.write(";");
                writer.newLine();
            }
        }
    }

    public interface Value extends Node {

        default @NotNull Reference.Index index(@NotNull String index) {
            return new Reference.Index(this, index);
        }

        record Constant(@NotNull String value, boolean quotations) implements Value {
            public Constant(@NotNull String value) {
                this(value, true);
            }

            public Constant(int value) {
                this(Integer.toString(value), false);
            }

            public Constant(@NotNull Object object) {
                this(Objects.toString(object), false);
            }

            public static final Constant Null = new Constant("null", false);

            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                if (quotations) {
                    writer.write("\"");
                    writer.write(value);
                    writer.write("\"");
                } else {
                    writer.write(value);
                }
            }
        }

        interface Reference extends Value {

            record Variable(@NotNull String reference) implements Reference {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    writer.write(reference);
                }
            }

            record Index(@NotNull Value previous, @NotNull String index) implements Reference {
                @Override
                public void generateSource(@NotNull IndentedStringWriter writer) {
                    previous.generateSource(writer);
                    writer.write(".");
                    writer.write(index);
                }
            }
        }

        /**
         * A method call.
         * e.g. "list.add(1)"
         */
        record MethodCall(@Nullable Value callingField,
                          @NotNull List<? extends Value> parameters) implements Value, Statement {

            public MethodCall(@Nullable Value callingField, @NotNull Value... parameters) {
                this(callingField, List.of(parameters));
            }

            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                if (callingField != null) {
                    callingField.generateSource(writer);
                }
                writer.write("(");
                for (int i = 0; i < parameters.size(); i++) {
                    if (i > 0) {
                        writer.write(", ");
                    }
                    parameters.get(i).generateSource(writer);
                }
                writer.write(")");
            }
        }
    }


    public record Type(String name) implements Node {

        public static final Type VOID = new Type("void");
        public static final Type INT = new Type("int");
        public static final Type LONG = new Type("long");
        public static final Type FLOAT = new Type("float");
        public static final Type DOUBLE = new Type("double");

        @Override
        public void generateSource(@NotNull IndentedStringWriter writer) {
            writer.write(name);
        }
    }

    /**
     * A top level node of the GLSL Bytecode tree.
     * Top level nodes are all nodes that are the children of the root node.
     */
    // TODO: Multi and single line
    public interface Comment extends GLSLBytecode.Statement {
        record Line(@NotNull String comment) implements Comment {
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                writer.write("// ");
                writer.write(comment);
                writer.newLine();
            }
        }

        record Block(@NotNull String comment) implements Comment {
            @Override
            public void generateSource(@NotNull IndentedStringWriter writer) {
                writer.write("/* ");
                writer.write(comment);
                writer.write(" */");
            }
        }
    }

    //////////
    // Data //
    //////////

    public static final Type INT = new Type("int");
    public static final Type FLOAT = new Type("float");
    public static final Type BOOL = new Type("bool");

    /////////////
    // Utility //
    /////////////

    public interface TopLevelNode extends Node {
    }
}
